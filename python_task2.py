# -*- coding: utf-8 -*-
"""Python_Task2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tOV_XoAoRA_XDpxBfNfzxkKnOoQkWyEM

Question 1: Distance Matrix Calculation
Create a function named calculate_distance_matrix that takes the dataset-3.csv as input and generates a DataFrame representing distances between IDs.

The resulting DataFrame should have cumulative distances along known routes, with diagonal values set to 0. If distances between toll locations A to B and B to C are known, then the distance from A to C should be the sum of these distances. Ensure the matrix is symmetric, accounting for bidirectional distances between toll locations (i.e. A to B is equal to B to A).
"""

import pandas as pd
import networkx as nx

def calculate_distance_matrix(dataset_path):
    # Load the dataset into a DataFrame
    df = pd.read_csv(dataset_path)

    # Create a graph using networkx
    G = nx.Graph()

    # Add edges with distances to the graph
    for _, row in df.iterrows():
        source_id, target_id, distance = row.iloc[0], row.iloc[1], row.iloc[2]
        G.add_edge(source_id, target_id, weight=distance)

    # Calculate the shortest path lengths between all pairs of nodes
    distance_matrix = nx.floyd_warshall_numpy(G, weight='weight')

    # Convert the distance matrix to a DataFrame
    distance_df = pd.DataFrame(distance_matrix, index=G.nodes(), columns=G.nodes())

    return distance_df

# Example usage
dataset_path = 'dataset-3.csv'
result_distance_matrix = calculate_distance_matrix(dataset_path)
print(result_distance_matrix)

"""Question 2: Unroll Distance Matrix
Create a function unroll_distance_matrix that takes the DataFrame created in Question 1. The resulting DataFrame should have three columns: columns id_start, id_end, and distance.

All the combinations except for same id_start to id_end must be present in the rows with their distance values from the input DataFrame.
"""

import pandas as pd

def unroll_distance_matrix(distance_matrix_df):
    # Create an empty DataFrame to store the unrolled distance matrix
    unrolled_df = pd.DataFrame(columns=['id_start', 'id_end', 'distance'])

    # Iterate over the rows of the distance matrix DataFrame
    for id_start in distance_matrix_df.index:
        for id_end in distance_matrix_df.columns:
            # Skip rows where id_start is equal to id_end
            if id_start != id_end:
                distance = distance_matrix_df.loc[id_start, id_end]
                unrolled_df = unrolled_df.append({'id_start': id_start, 'id_end': id_end, 'distance': distance},
                                                 ignore_index=True)

    return unrolled_df

# Example usage
# Assuming result_distance_matrix is the DataFrame obtained from Question 1
result_unrolled_df = unroll_distance_matrix(result_distance_matrix)
print(result_unrolled_df)

"""Question 3: Finding IDs within Percentage Threshold
Create a function find_ids_within_ten_percentage_threshold that takes the DataFrame created in Question 2 and a reference value from the id_start column as an integer.

Calculate average distance for the reference value given as an input and return a sorted list of values from id_start column which lie within 10% (including ceiling and floor) of the reference value's average.
"""

import pandas as pd

def find_ids_within_ten_percentage_threshold(unrolled_df, reference_value):
    # Filter rows for the given reference value
    reference_rows = unrolled_df[unrolled_df['id_start'] == reference_value]

    # Check if the reference value is present in the DataFrame
    if reference_rows.empty:
        return []  # Return an empty list if the reference value is not found

    # Calculate the average distance for the reference value
    average_distance = reference_rows['distance'].mean()

    # Calculate the lower and upper bounds for the threshold
    lower_bound = 0.9 * average_distance
    upper_bound = 1.1 * average_distance

    # Filter rows within the 10% threshold
    within_threshold = unrolled_df[
        (unrolled_df['distance'] >= lower_bound) & (unrolled_df['distance'] <= upper_bound)
    ]

    # Get unique values from the id_start column and sort them
    result_list = sorted(within_threshold['id_start'].unique())

    return result_list

# Example usage
# Assuming result_unrolled_df is the DataFrame obtained from Question 2
# Ensure that the reference value exists in the DataFrame
reference_value = 123  # Replace with the desired reference value
result_within_threshold = find_ids_within_ten_percentage_threshold(result_unrolled_df, reference_value)

if not result_within_threshold:
    print(f"No matches found for reference value {reference_value}")
else:
    print(result_within_threshold)

"""Question 4: Calculate Toll Rate
Create a function calculate_toll_rate that takes the DataFrame created in Question 2 as input and calculates toll rates based on vehicle types.

The resulting DataFrame should add 5 columns to the input DataFrame: moto, car, rv, bus, and truck with their respective rate coefficients. The toll rates should be calculated by multiplying the distance with the given rate coefficients for each vehicle type:

0.8 for moto
1.2 for car
1.5 for rv
2.2 for bus
3.6 for truck
"""

import pandas as pd

def calculate_toll_rate(unrolled_df):
    # Define rate coefficients for each vehicle type
    rate_coefficients = {'moto': 0.8, 'car': 1.2, 'rv': 1.5, 'bus': 2.2, 'truck': 3.6}

    # Iterate over the rate coefficients and calculate toll rates for each vehicle type
    for vehicle_type, rate_coefficient in rate_coefficients.items():
        # Create a new column with the toll rate for the current vehicle type
        unrolled_df[vehicle_type] = unrolled_df['distance'] * rate_coefficient

    return unrolled_df

# Example usage
# Assuming result_unrolled_df is the DataFrame obtained from Question 2
result_with_toll_rates = calculate_toll_rate(result_unrolled_df)
print(result_with_toll_rates)

"""Question 5: Calculate Time-Based Toll Rates
Create a function named calculate_time_based_toll_rates that takes the DataFrame created in Question 3 as input and calculates toll rates for different time intervals within a day.

The resulting DataFrame should have these five columns added to the input: start_day, start_time, end_day, and end_time.

start_day, end_day must be strings with day values (from Monday to Sunday in proper case)
start_time and end_time must be of type datetime.time() with the values from time range given below.
Modify the values of vehicle columns according to the following time ranges:

Weekdays (Monday - Friday):

From 00:00:00 to 10:00:00: Apply a discount factor of 0.8
From 10:00:00 to 18:00:00: Apply a discount factor of 1.2
From 18:00:00 to 23:59:59: Apply a discount factor of 0.8
Weekends (Saturday and Sunday):

Apply a constant discount factor of 0.7 for all times.
For each unique (id_start, id_end) pair, cover a full 24-hour period (from 12:00:00 AM to 11:59:59 PM) and span all 7 days of the week (from Monday to Sunday).

Sample result dataframe:
"""

import pandas as pd

def get_bus_indexes(df):
    # Calculate the mean value of the 'bus' column
    bus_mean = df['bus'].mean()

    # Identify indices where 'bus' values are greater than twice the mean
    bus_indexes = df[df['bus'] > 2 * bus_mean].index.tolist()

    # Sort the indices in ascending order
    bus_indexes.sort()

    return bus_indexes

# Example usage
dataset_path = 'dataset-1.csv'
df = pd.read_csv(dataset_path)
result = get_bus_indexes(df)
print(result)

import pandas as pd
from datetime import time

def calculate_time_based_toll_rates(your_dataframe):
    # Assuming your_dataframe has columns: 'startDay', 'startTime', 'endDay', 'endTime'
    your_dataframe['start_time'] = pd.to_datetime(your_dataframe['startTime']).dt.time
    your_dataframe['end_time'] = pd.to_datetime(your_dataframe['endTime']).dt.time

    # Define time ranges and discount factors
    time_ranges = [
        {'start': time(0, 0), 'end': time(10, 0), 'factor': 0.8},
        {'start': time(10, 0), 'end': time(18, 0), 'factor': 1.2},
        {'start': time(18, 0), 'end': time(23, 59, 59), 'factor': 0.8}
    ]

    # Apply discount factors based on time ranges
    for tr in time_ranges:
        mask = (your_dataframe['start_time'] >= tr['start']) & (your_dataframe['end_time'] <= tr['end'])
        your_dataframe.loc[mask, 'discount_factor'] = tr['factor']

    # Apply a constant discount factor for weekends
    weekend_mask = your_dataframe['startDay'].isin(['Saturday', 'Sunday'])
    your_dataframe.loc[weekend_mask, 'discount_factor'] = 0.7

    # Apply the discount factor to vehicle columns
    vehicle_columns = ['moto', 'car', 'rv', 'bus', 'truck']
    for col in vehicle_columns:
        your_dataframe[col] = your_dataframe[col] * your_dataframe['discount_factor']

    return your_dataframe